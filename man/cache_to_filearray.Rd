% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/filearray.R
\name{cache_to_filearray}
\alias{cache_to_filearray}
\title{Generate and automatically cache a file array}
\usage{
cache_to_filearray(
  fun,
  filebase,
  globals,
  dimension,
  type = "auto",
  partition_size = 1L,
  verbose = FALSE,
  ...
)
}
\arguments{
\item{fun}{function that can be called with no mandatory arguments; the
result should be in a matrix or an array}

\item{filebase}{where to store the array}

\item{globals}{names of variables such that any changes
should trigger a new evaluation of \code{fun}. This argument is highly
recommended to be set explicitly (with atomic variables) though the
function automatically calculates the global variables}

\item{dimension}{what is the supposed dimension, default is automatically
calculated from array. If specified explicitly and the file array dimension
is inconsistent, a new calculation will be triggered.}

\item{type}{file array type, default is \code{"auto"}; can be explicitly
specified; see \code{\link[filearray]{filearray_create}}. Inconsistent
type will trigger a new calculation.}

\item{partition_size}{file array partition size; default is \code{1};
set it to \code{NA} to generate it automatically. Notice inconsistent
partition size will not trigger calculation if the key variables remain
the same}

\item{verbose}{whether to verbose debug information}

\item{...}{passed to \code{\link[globals]{findGlobals}}}
}
\description{
Avoid repeating yourself
}
\examples{


c <- 2
b <- list(d = matrix(1:9,3))
filebase <- tempfile()

f <- function() {
  message("New calculation")
  re <- c + b$d
  dimnames(re) <- list(A=1:3, B = 11:13)

  # `extra` attribute will be saved
  attr(re, "extra") <- "extra meta data"
  re
}

# first time running
arr <- cache_to_filearray( f, filebase = filebase )

# cached, no re-run
arr <- cache_to_filearray( f, filebase = filebase )

# file array object
arr

# read into memory
arr[]

# read extra data
arr$get_header("extra")

# get digest results
arr$get_header("raveio::filearray_cache")

## Clean up this example
unlink(filebase, recursive = TRUE)

}
