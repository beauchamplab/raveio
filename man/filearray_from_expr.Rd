% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/filearray.R
\name{filearray_from_expr}
\alias{filearray_from_expr}
\title{Generate and automatically cache a file array}
\usage{
filearray_from_expr(
  expr,
  filebase,
  globals,
  dimension,
  type = "auto",
  partition_size = 1L,
  quoted = FALSE,
  env = parent.frame(),
  verbose = FALSE,
  ...
)
}
\arguments{
\item{expr}{expression that should result in a matrix or an array}

\item{filebase}{where to store the array}

\item{globals}{names of variables such that any changes
should trigger a new evaluation of \code{expr}. This argument is highly
recommended to be set explicitly (with atomic variables) though the
function automatically calculates the global variables}

\item{dimension}{what is the supposed dimension, default is automatically
calculated from array. If specified explicitly and the file array dimension
is inconsistent, a new calculation will be triggered.}

\item{type}{file array type, default is \code{"auto"}; can be explicitly
specified; see \code{\link[filearray]{filearray_create}}. Inconsistent
type will trigger a new calculation.}

\item{partition_size}{file array partition size; default is \code{1};
set it to \code{NA} to generate it automatically. Notice inconsistent
partition size will not trigger calculation if the key variables remain
the same}

\item{quoted}{whether \code{expr} has been quoted; default is false}

\item{env}{environment where to evaluate \code{expr}; the evaluation will
be clean, meaning that intermediate variables in the expression will not
be available in \code{env}.}

\item{verbose}{whether to verbose debug information}

\item{...}{passed to \code{\link[globals]{findGlobals}}}
}
\description{
Avoid repeating yourself
}
\examples{


c <- 2
b <- list(d = matrix(1:9,3))
filebase <- tempfile()

expr <- quote({
  message("New calculation")
  re <- c + b$d
  dimnames(re) <- list(A=1:3, B = 11:13)
  re
})

# first time running
arr <- filearray_from_expr(
  expr, quoted = TRUE,
  filebase = filebase
)

# cached, no re-run
arr <- filearray_from_expr(
  expr, quoted = TRUE,
  filebase = filebase
)

# file array object
arr

# read into memory
arr[]

# get digest results
arr$get_header("raveio::filearray_cache")

## Clean up this example
unlink(filebase, recursive = TRUE)

}
