% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/class-variable-constraint.R
\name{new_constraints}
\alias{new_constraints}
\alias{new_constrained_variable}
\title{Create \code{'RAVE'} constrained variables}
\usage{
new_constraints(type, assertions = NULL)

new_constrained_variable(name, initial_value, constraints = NULL, ...)
}
\arguments{
\item{type}{variable type; \code{checkmate::assert_*} will be automatically
applied if applicable}

\item{assertions}{named list; each name stands for an assertion type, and
the corresponding item can be one of the follows; please see 'Examples'
for usages.
\describe{
\item{list of arguments or \code{NULL}}{name of the assertion must be a valid
assertion function in package \code{checkmate}. For example,
\code{list(numeric=NULL)} will call \code{checkmate::assert_numeric} when
value is validated}
\item{a function}{name of the assertion can be arbitrary, users are in
charge of the validation function. This function should take only one
argument and return either \code{TRUE} if the validation passes, or
a character of the error message.}
}}

\item{name}{\code{character(1)}, variable name}

\item{initial_value}{initial value, if missing, then variable will be
assigned with an empty list with class name \code{'key_missing'}}

\item{constraints, ...}{when \code{constraints} is an instance of
\code{RAVEVariableConstraints}, \code{...} will be ignored. When
\code{constraints} is a string, then \code{constraints} will be passed to
\code{new_constraints} (see argument \code{type}), and \code{...} will be
packed as assertion parameters (see \code{assertions})}
}
\description{
Create a variable that automatically validates
}
\examples{

# ---- Basic usage ----------------------------------------
analysis_range <- new_constrained_variable("Analysis range")

# Using checkmates::assert_numeric
analysis_range$use_constraints(
  constraints = "numeric",
  any.missing = FALSE,
  len = 2,
  sorted = TRUE,
  null.ok = FALSE
)

analysis_range$initialized # FALSE
print(analysis_range)

# set value
analysis_range$set_value(c(1, 2))

# get value
analysis_range$value   # or $get_value()

# ---- Fancy constraints ------------------------------------
# construct an analysis range between -1~1 or 4~10
time_window <- validate_time_window(c(-1, 1, 4, 10))
analysis_range <- new_constrained_variable("Analysis range")
analysis_range$use_constraints(
  constraints = new_constraints(
    type = "numeric",
    assertions = list(
      # validator 1
      "numeric" = list(
        any.missing = FALSE,
        len = 2,
        sorted = TRUE,
        null.ok = FALSE
      ),

      # validator 2
      "range" = function(x) {
        check <- FALSE
        if(length(x) == 2) {
          check <- sapply(time_window, function(w) {
            if(
              x[[1]] >= w[[1]] &&
              x[[2]] <= w[[2]]
            ) { return (TRUE) }
            return( FALSE )
          })
        }
        if(any(check)) { return(TRUE) }

        valid_ranges <- paste(
          sapply(time_window, function(w) {
            paste(sprintf("\%.2f", w), collapse = ",")
          }),
          collapse = "] or ["
        )
        return(sprintf("Invalid range: must be [\%s]", valid_ranges))
      }
    )
  )
)

# validate and print out error messages
# remove `on_error` argument to stop on errors
analysis_range$validate(on_error = "message")

# Try with values (-2,1) instead of c(0,1)
analysis_range$value <- c(0, 1)

print(analysis_range)


}
